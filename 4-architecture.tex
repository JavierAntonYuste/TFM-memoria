\chapter{System architecture}
% arquitectura del sistema
%API python
% web
\label{chap:architecture}

\textit{In this chapter we are going to describe a selected use case. This section will discuss the two use case: Sentiment and Emotion Analysis applying Deep Learning techniques, which will include the datasets used, the first steps with the neural networks and the use of more advance techniques.}

\clearpage

\section{General Architecture}

%This chapter will serve as a description of the methodology that has been followed in order to develop the system and meet the requirements set out in the Chapter~\ref{chap:introduction}. As mentioned, this work arises from the need of tackling a problem in today's society, namely Eating Disorders. More specifically, the aim is to help in the early detection of such illnesses so that they can be treated as soon as possible.

The aim of this project is to help in the early detection of Eating Disorders so that they can be treated as soon as possible. To achieve that, the system's presentation should be easy to handle and understandable for the people who use it. Furthermore, it has to be visually appealing in order to motivate people with a potential Eating Disorder to use it.

The presentation layer of this Master Thesis has been designed using a specific methodology based on states called bloc, which will be explained in this chapter. There are diferent parts that are part of this bloc architecture that need to be implemented in order to perform different actions that will enhance the user experience.

To serve this presentation layer with data, a server has been implemented in which an API has been constructed. The objective of this is to consult the information about the required user and predict the suffering of an Eating Disorder. This server makes calls to the Twitter API also to make the prediction using the Machine Learning model previously preloaded on the same server. The model that has been followed for implementing this part of the system is called Front Controller, which will be explained here.

The system architecture that has been developed for this Master Thesis can be seen in the Figure~\ref{fig:architecture}, where you can find the interactions between the subcomponents in a simplified diagram.

% Mostrar esquema arquitectura
\begin{figure}[h]
    \centering
    \includegraphics[width=1.05\textwidth]{img/architecture/architecture.drawio.png}
    \caption{Simplified diagram of the architecture of the system}
    \label{fig:architecture}
\end{figure}


In this figure you can see a simplified abstract diagram of the structure of our system, consisting of two distinct elements, which are the server made with Flask and the user interface for which Flutter has been used. In the following we will break down this architecture and zoom in on the different parts to explain what the elements represented in the diagram above consist of and what function they have.


\section{Flask server}
\label{sec:server}
% Funciones que realiza: Extraccion datos, procesamiento y predicción
 In this section we are going to focus on the part that obtains and processes the data from our application in order to be able to make a prediction about the user we want to analyse. The basic functions of this are data extraction, data processing and the generation of a prediction that is returned in JSON format as a response, along with additional information.
 
 We needed a technology that was fast and light as we didn't want to overcomplicate the text processing, we just wanted it to be easy to query to get the best user experience and reduce waiting times. For this reason we chose Flask, a fairly mature lightweight framework for Python, which allows us to set up a server in a matter of seconds and process requests quickly.
 
 
 
 % MODELO SEGUIDO en  arquitectura: FRONT CONTROLLER
 The model followed to implement this Flask server is the Front Controller model, which can be seen in the Figure~\ref{fig:front-controller}. This model is based on a controller that handles all requests from a server, which is useful to achieve flexibility and reuse code without redundancy.

 
\begin{figure}[h]
    \centering
    \includegraphics[width=0.65\textwidth]{img/architecture/Front_Controller.png}
    \caption{Example of Front Controller architecture}
    \label{fig:front-controller}
\end{figure}

These front controllers are normally used in web applications like the one in this project to implement flows. It serves to simplify navigation between screens and is invoked every time calls are made to the server. This Front Controller handles all the tasks common to the application, such as session, caching and in our case routing and invocation of data extraction through implemented methods.

This was the most interesting option and the one that best suited what we were looking for in this Master Thesis, as we took into account the features that we needed and the simplicity the model provides to perform and implement those features. 

The alternative would have been to have individual scripts that respond to each request, which can lead to duplication of both code and objects. Finally, this implementation was discarded because of the benefits that a front controller brings in terms of escalation and life.

The features that we required from this sever are as mentioned before, three main tasks, which are data extraction, data processing with its prediction, and data serving through the API which we will break them out in the following.

% 1. Extraccion de datos
\myparagraph{Data extraction}
The focus of this project is on the social network Twitter and because of this, we need to extract information from Twitter in order to achieve our goal. We want to analyse per user the suffering of an Eating Disorder so we need to extract the latest tweets of a specific person in order to treat them and introduce them as input to our model.

For this, we used a Python-based tool called snscrape~\cite{JustAnot83:online}, which can extract data from the Twitter API without us having to authenticate ourselves. The possibility of creating a Developer account on Twitter was considered and emails were exchanged with the administration, but it was found that there were many more complications than using this tool. 

This snscrape Python package that can be easily installed using the pip manager, allows us to take as many tweets as we want from a profile and put them in a text file in JSON format, as it can be seen in the code block described in Appendix~\ref{appendix:JSONsnscrape}.

So, it was decided to use snscrape for its simplicity and for not needing to authenticate to the API. With the command written in the Code~\ref{code:snscrape} we can access the 1000 most recent tweets of the user with the identifier \$username and save them in JSON format in the file user-tweets.json.

Subsequently, we will read this file to be able to process the information taken. The tool has more functionalities such as searching Twitter (twitter-search) or consulting a profile (twitter-profile) but this one is enough for the given approach.

\begin{lstlisting}[caption={Command executed for obtaining tweets}, label={code:snscrape}]
snscrape --jsonl --max-results 1000 twitter-user $username > user-tweets.json
\end{lstlisting}

Once we have the file ready, we read it using the pandas library in order to ingest it into our model, preprocessing it beforehand. This file is given a personal character because after reading the file, it is deleted from the server so as not to generate overload. Now, in the next paragraph, we will explain how we preprocess the text once it is read.

% 2. Procesamiento de datos (empaquetamiento de modelo) / wordcloud y prediccion
\myparagraph{Data processing and prediction}
We need to process the data obtained from twitter in our platform, so we will treat the information in a similar way in this Flask server to the one explained in~\ref{sec:preprocessing}, as we want our model to work in a similar way as it did with the validation data because it gave us good results. 


So, what we do is reuse the code written in Code~\ref{code:preprocessing} for this data extracted from Twitter. As a result we get an array of words from the last tweets published by the user in question.

%Wordcloud
In addition, we took the opportunity of having this to create more statistics and to give the user more insights. For example, we have implemented the creation of a wordcloud that reflects the most used words and their frequency in a very intuitive graphical way.

% 3. Como se sirven los datos: rutas y por JSON --> API
\myparagraph{Data serving through API}
%JSON Format and wordcloud img processing
To serve the prediction and additional statistics the API has been programmed as above. This API has a dedicated path to return the extracted results in JSON format.

The simplified output obtained by querying the API as can be seen in the Code~\ref{code:jsonapi} is a composition of the prediction result, user information and the wordcloud image in base64 format. This information is then used in the Flutter part to build the user interface.

%% METER EJEMPLO JSON
\begin{lstlisting}[caption={JSON output from API}, label={code:jsonapi}]
{
    "prediction": "0", 
    "username": "elonmusk", 
    "pic": "https://pbs.twimg.com/profile_images/1529956155937759233/Nyn1HZWF.jpg", 
    "wordcloud": "iVBORw0KGgoAAAANSUhEUgAAAZAAAADICAIAAAB..."
}
\end{lstlisting}


In order to be able to send the wordcloud image through the API, it has to be encoded in base64 format. Subsequently, it has to be decoded in the application part in order to be displayed.\\\\
In the following section we will focus on the application that the user uses, presenting its parts, the model used in its design and its structure.
\section{Flutter application}
% Presentacion de la aplicacion
The application aims to have a clear and guided user experience that engages the user for using it. It should have a clear flow for easing its manipulation and really help the person who uses it. Because of that we used Flutter for implementing it.

%Multiplataforma
It is a Flutter-based as it is mentioned, so that implies that it is a cross-platform application that can be seen in Android, iOS and web, which make it polivalent. Its content is dinamically treated so it adjusts to all kinds and sizes of screen, which has been also take into account in the design process.

% Diseño de la app: BLOC
The design pattern followed is called BloC, which makes our application based on separate components. These components contain only the business logic, \textit{i.e.} the logic that determines how information can be created, stored and changed.

BLoC is widely used in applications developed in Flutter, as it is based on widgets and BLoC helps to communicate these widgets with other components of the application.

This communication is done through the issuing of events from the UI as shown in the Figure~\ref{fig:bloc}. BLoC interprets this and transforms it into states and emits streams back to the UI to make the relevant changes to the interface. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{img/architecture/bloc.png}
    \caption{BLoC architecture}
    \label{fig:bloc}
\end{figure}

In turn, our BLoC-based application is packed with repositories, which serve to obtain data necessary for the application, as in this case is the prediction of our system issued by the Flask server explained before. The repository of our system provides access to long-term state data, in our case via API.

% Planteamiento de la estructura general: repositories, etc
